1ï¸âƒ£ What is Longest Common Subsequence (LCS)? (Very Simple)
First: What is a Subsequence?

A subsequence:

Keeps order

Characters donâ€™t need to be continuous

Example:

String = "ABCDE"
Subsequence = "ACE" âœ…
Subsequence = "AEC" âŒ (order changed)
Now LCS means:

The longest sequence of characters that appears in BOTH strings in the SAME ORDER (not necessarily continuous)

2ï¸âƒ£ Simple Example (Understand First)
String 1 = "ABC"
String 2 = "AC"

Common subsequences:

"A"

"C"

"AC" âœ… (longest)

ğŸ‘‰ LCS length = 2

3ï¸âƒ£ Important Rules / Criteria (Must Remember)
âœ… Rule 1: Order must be preserved

"ABC" & "BAC" â†’ "AC" is valid, "BA" is not

âœ… Rule 2: Characters need NOT be continuous

Gaps are allowed

âœ… Rule 3: We want the longest possible subsequence
âŒ Not substring

Substring must be continuous
Subsequence does not

4ï¸âƒ£ Why Dynamic Programming (DP)?
Brute force problem:

Try all subsequences â†’ 2â¿ combinations âŒ

DP idea (simple):

Solve smaller string comparisons and reuse results

5ï¸âƒ£ DP Table Meaning (MOST IMPORTANT)

Let:

dp[i][j]
Meaning:

Length of LCS between
first i characters of string1
first j characters of string2

6ï¸âƒ£ DP Decision Logic (Heart of LCS)
Case 1ï¸âƒ£: Characters match
s1[i-1] == s2[j-1]

ğŸ‘‰ Include this character
ğŸ‘‰ Add 1 to previous result

dp[i][j] = 1 + dp[i-1][j-1]
Case 2ï¸âƒ£: Characters do NOT match

ğŸ‘‰ Ignore one character (try both ways)

dp[i][j] = max(
    dp[i-1][j],   // ignore char from s1
    dp[i][j-1]    // ignore char from s2
)
7ï¸âƒ£ Visual DP Table (Understand Clearly)

Example:

String 1 = "ABCBDAB"
String 2 = "BDCAB"

Final DP table value = LCS length

8ï¸âƒ£ Very Simple Java Program (DP)
public class LCS {


    public static void main(String[] args) {


        String s1 = "ABC";
        String s2 = "AC";


        int m = s1.length();
        int n = s2.length();


        // DP table
        int[][] dp = new int[m + 1][n + 1];


        // Build the table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {


                // If characters match
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }
                // If characters do not match
                else {
                    dp[i][j] = Math.max(
                            dp[i - 1][j],
                            dp[i][j - 1]
                    );
                }
            }
        }


        System.out.println("LCS Length: " + dp[m][n]);
    }
}
